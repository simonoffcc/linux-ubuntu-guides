1. `cd /usr/src/` - не сделал (там лежат папки всех ядер, а я распаковал просто в домашней папке)
    
    `wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.2.1.tar.xz`
   
2. `tar xvf linux-6.2.1.tar.xz`

3. `sudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison`

[Пакеты Linux для сборки ядра Flashcards](https://quizlet.com/_cypy9k?x=1jqt&i=4b79qc)

4. `cd linux-6.2.1`

5. `sudo cp -v /boot/config-$(uname -r) .config`

6. `make menuconfig`

7. `sudo nano .config`
    - для быстрого поиска в файле используем “ctrl + w”
    
    ```bash
    CONFIG_SYSTEM_TRUSTED_KEYS=""       # находим эти поля и ставим пустые кавычки
    CONFIG_SYSTEM_REVOCATION_KEYS=""
    ```
    
    - сохраняем файл

8. `make` (по умолчанию 1 поток)
    
    или
    
    `make -jN` (где N - количество потоков, которое будет задействовано при сборке)
---

**Команды windows для расширения памяти диска виртуалки (не помогло)**

`cd "D:\Programs\Oracle\VirtualBox"`

`VBoxManage modifyhd "D:\Programs\VirtualBox VMs\Ubuntu\Ubuntu.vdi" --resize 65536`

Через виртуал-бокс и винду увеличить объём памяти не получилось, поэтому я забил и просто *переустановил виртуалку, выделив при этом 64 гб памяти для виртуалки, шоб наверняка.*

---

1. `sudo make modules_install`

2. `sudo make install`
    
3. `sudo update-initramfs -c -k 6.2.1`
    
4. `sudo update-grub2`

5. `sudo reboot`

6. `uname -r`

---

# Выяснение информации об аппаратной платформе для выполнения отчёта

`sudo lshw -short` - **список железных компонентов**

`lscpu` - **информации о процессорных мощностях**

`lspci` - **список PCI**

`lsscsi` - **список SCSI устройств**

`df` **** - **информация о пространстве файловой системы**

### файлы /proc

В директории **/proc** существует целое множество файлов, 
содержимое которых расскажет множество интересной и полезной информации о
 компонентах. Например, информация о CPU и памяти:

- cpu информация
    
    `cat /proc/cpuinfo`
    
- информация о памяти
`cat /proc/meminfo`
- информация об операционной системе
    
    `cat /proc/version`
    

---

## Циклическая сборка ядра

`make clean` - очистить каталог от всех файлов полученных в результате компиляции

`nano kernelCyclicBuild.sh`

```bash
#!/bin/bash

cd linux-6.2.1
make clean > /dev/null
for ((i = 0; i < 10; i++ ))
do
{ time make -j$i > /dev/null ; } 2>&1 | grep real
make clean > /dev/null
done
```

<aside>
❔ [Что такое `..2>&1 | grep real` ?](https://stackoverflow.com/questions/17257724/grep-time-command-output) По дефолту, утилита `time` выводит инфу в поток ошибок, то есть в 2. Поэтому необходимо перенаправить поток ошибок в поток вывода, то есть в 1. В свою очередь `grep real` означает вывод только строки *real* (кроме *user* и *sys*) - общего времени от начала выполнения процесса и до его завершения.

</aside>

`chmod +x kernelCyclicBuild.sh`

`./kernelCyclicBuild.sh`

В зелёном квадратике - результаты, которые были получены на ноуте, питаемым от сети

В красном - по идее испорченные значения, которые были собраны чисто на батарее не в режиме максимальной производительности. 

Желательно, для точных результатов следует собрать ядро ещё раз по циклу, но можно начиная с 5 потоков.

1. 76 + 57
2. 68
3. 68
4. 68
5. 68

---

## Индивидуальное задание № 4 - Ускорение сборки ядра за счёт использования каналов

> Цель работы – ускорение сборки ядра за счёт использования каналов.
> 

### Задание

- собрать ядро без использования символьной информации без использования каналов вместо временных файлов (см. опцию pipe в GCC)
- собрать ядро без использования символьной информации с использованием каналов вместо временных файлов
- определить ускорение времени сборки за счёт использования каналов

---

<aside>
❔ Что такое [символьная информация](https://ru.stackoverflow.com/questions/1383146/%D0%A1%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D1%80%D0%B8-%D1%81%D0%B1%D0%BE%D1%80%D0%BA%D0%B5-%D1%8F%D0%B4%D1%80%D0%B0-linux)?

</aside>

Чтобы отключить её при сборке ядра, в файле `.config` нужно закомментировать строчку с переменной `CONFIG_DEBUG_INFO`

Чтобы наоборот включить, нужно в том же файле `.config` прописать строчку `CONFIG_DEBUG_INFO=y`

По сути дела, это же можно сделать красивее в `menuconfig`, но это уже другая история

---

[Распараллеливание процессов](https://habr.com/ru/company/xakep/blog/210480/) - решение.
***Из стаьи***: 

Чтобы выиграть еще немного времени, можно добавить ключ '-pipe' к GCC. С этим ключом передача данных между разными стадиями компиляции происходит через каналы обмена (pipes), а не через временные файлы, что немного (совсем немного) ускоряет процесс.

---

### Ход работы

1. `sudo nano .config`
    
    `CONFIG_DEBUG_INFO` → `#CONFIG_DEBUG_INFO`
    
    `time make -j6` - сборка с 6-ю потоками, т.к. выводы из основной проделанной лабораторной работы показали, что для сборки ядра это кол-во потоков является наиболее эффективным.
    
    **Результат:** `87m38,402s` - 5258 секунд

2. …
    
    **Результат:** 82m17,982s - 4998 секунд
    
3. Прирост - всего 1% (0,9505515405)

Результат неудовлетворительный.

---

https://www.opennet.ru/docs/RUS/gnumake/#Make

https://wiki.gentoo.org/wiki/GCC_optimization/ru#-pipe

https://stackoverflow.com/questions/23407635/append-compile-flags-to-cflags-and-cxxflags-while-configuration-make

http://computerlib.narod.ru/html/gcc.htm

---

### 2 попытка

`time make -j$(nproc) CFLAGS="-pipe -O2 -fomit-frame-pointer"`

ФЭЙЛ.

---

### 3 попытка

`time make -j4 CFLAGS="-pipe"`

ФЭЙЛ.

---

### 4 попытка (подсказка добрых людей с беседы потока)

`time make -j4 "CFLAGS_KERNEL=-pipe"`

************Результат:************ 73m4,368s - 4384 секунд

Разница = 874 секунд

**************Прирост скорости сборки: 16%**

---

Теория про make: https://habr.com/ru/post/211751/

---

`time make -j$(nproc) FEATURES="-ccache"`
